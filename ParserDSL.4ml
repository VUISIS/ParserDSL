domain Parser {

    // Parser Abstraction
    // 1. A while loop in which a pointer points to current read and keeps moving forward towards the end.
    // 2. Variables for storing intermediate results such as a counter.
    // 3. Case switching based on the content at current pointer and other intermediate results to decide the length 
    // of the next read.
    // 4. Transform, update and output the current read and intermediate results.

    // The next read might be determined by the value of current read and other intermediate values. 
    // For example, TAR parser is different from regex and programming language parser that parse linearly.
    // The first read of 64 bytes could be an integer as `x` and the next read will consume the next `x` blocks. 

    UnOp  ::= { LNOT,  BNOT, NEG,  POS,
                 ADDR,  DRF,  INC,  DEC,
                 INCAFTER, DECAFTER, ATOI }.
    
    BinOp ::= { ADD,   SUB,  DIV,   MUL, MOD, 
                 LAND,  LOR,  BAND,  BOR, BXOR,
                 RT,    LFT,  CMA,   FLD,
                 PFLD,  LT,   LE,    GT,  
                 GE,    EQ,   NEQ,   AAC }.

    Literal ::= Integer + String + Var + Val.

    // TODO: Add dictionary if dict has to be used in a parser.
    // A variable has a name and contain Integer, String or a list 
    Var ::= new (name: String, val: Val + Vals).
    Vars ::= new (var: Var, tail: any Vars + {NIL}).

    Val  ::= new (val: String + Integer).
    Vals ::= new (arg: Val, tail: any Vals + { NIL }).

    List ::= new (name: String, list: Vals + { NIL}).

    Case   ::= new (condition: any Expr, body: any Stmts).                
    Cases  ::= new (case: any Case, tail: any Cases + {NIL}).   
    Switch ::= new (switch: any Expr, cases: any Cases). 
    
    UnApp   ::= new (op: any UnOp, arg1: any Expr).
    BinApp  ::= new (op: any BinOp, arg1: any Expr, arg2: any Expr).
    FunApp  ::= new (op: any Expr, args: any Vals).

    Expr ::= UnApp + BinApp + FunApp + Literal.
    Stmt ::= Expr + Switch + NextRead.
    Stmts  ::= new (arg: any Stmt, tail: any Stmts + {NIL}).   

    NextRead ::= new (pos: Integer + {NIL}, len: Expr).

}

model CalcParser of Parser {
    number is Var("number", Val(0)).
    sign_value is Var("sign_value", Val(1)).
    result is Var("result", Val(0)).
    op_stack is List("op_stack", NIL). 
    
    cond1 is BinApp(EQ, Var("c", Val(0)), Val(0)).
    stmt1 is BinApp(ADD, BinApp(MUL, number, Val(10)), UnApp(ATOI, Var("c", Val(0)))).
    // Increment the read pointer by only 1 step.
    stmt2 is NextRead(NIL, Val(1)).
    body1 is Stmts(stmt1, Stmts(stmt2, NIL)).
    case1 is Case(cond1, body1).
     
}