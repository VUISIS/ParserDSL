domain SimpleTarParser
{
  Header ::= new (name: Integer, size: Integer).
  Offset ::= new (name: Integer, pos: Integer).
  Start  ::= new (name: Integer).
  Done  ::= new (name: Integer, seq: Integer).

  Done(nextName, 0) :- s is Start(currName), 
                          currHeader is Header(currName, size),
                          currOffset is Offset(currName, pos),
                          nextPos = pos + size + 512,
                          nextOffset is Offset(nextName, nextPos).
                          
  Done(nextName, nextSeq) :- s is Done(currName, seq), nextSeq = seq + 1,
                          currHeader is Header(currName, size),
                          currOffset is Offset(currName, pos),
                          nextPos = pos + size + 512,
                          nextOffset is Offset(nextName, nextPos).

  badHeader :- h is Header, h.size < 0.

  // Must have exactly one StartHeader
  tooManyDone :- h is Header, name = h.name,
                    count({d | d is Done(name, _)}) > 1. 
  
  // conforms no tooManyDone, no badHeader.
}

partial model pm0 of SimpleTarParser
[solver_RecursionBound = 5]
{
  h1 is Header(100, 512).
  h1Offset is Offset(100, 0).
  Start(100).
  
  h2 is Header(101, x).
  h2Offset is Offset(101, 1024).
}

// A parser domain with dependent data types and intermediate results
domain GenericDataParser {
    // Define constants for parsing status
    Status ::= {INIT, READ, UPDATE, TERMINATE, DONE}.

    // A byte represented as an integer in the range of 0-255 and its location in the input data.
    Byte ::= new (input: InputData, val: Natural, pos: Integer).
    // Input data are bytes represented as a list of Byte.
    InputData ::= new (name: String, data: String, length: Integer).

    // Parsing state that the includes the input data, status, current position, and offset.
    State ::= new (inputData: InputData, status: Status, curPos: Integer, offset: Integer).

    // Intermediate results that are derived during parsing and the derived result could have my types.
    IntermediateResult ::= new (name: String, context: State, derivedResult: String + Integer + { NULL }).

    // Decide the new offset, pos and intermediate result based on current state.
    NextOffset ::= new (context: State, offset: Integer).
    NextPos ::= new (context: State, pos: Integer).
    NextIntermediateResult ::= new (var: String, context: State, result: String + Integer + { NULL }).

    CanReadMore ::= new (context: State).
    CanReadMore(state) :- state is State(InputData(_, _, length), _, pos, offset), 
        pos + offset < length.

    // Rule to move to done state
    State(inputData, DONE, pos, offset) :-
        inputData is InputData(name, data, length),
        State(inputData, READ, pos, offset), 
        offset + pos >= length.

    isDone :- State(_, DONE, _, _).

    // Rule to initialize the parser with no intermediate results, but you can add them as needed.
    State(initData, INIT, 0, 0) :- initData is InputData(_,_,_). // Change this logic as needed

    // Rule to read the next block of data based on the NextPos and NextOffset.
    State(inputData, READ, newPos, newOffset) :-
        state is State(inputData, READ, pos, offset),
        NextPos(state, newPos),
        NextOffset(state, newOffset),
        CanReadMore(state).
    
    // Rule to update intermediate results from current read and other intermediate results.
    // The new status is changed from READ to UPDATE while keeping other parameters the same.
    IntermediateResult(name, newState, newDerivedResult) :-
        state is State(inputData, READ, pos, offset), 
        IntermediateResult(name, state, derivedResult),
        NextIntermediateResult(name, newState, newDerivedResult),
        newState = State(inputData, UPDATE, pos, offset).
}

domain TinyDemoParser extends GenericDataParser {
    // Rule to initialize parsing and read the initial header or meta info.
    State(inputData, READ, pos, offset) :- State(inputData, INIT, 0, 0),
        pos = 0, offset = 1. 

    // Read the header and update the intermediate result with the count of numbers to read next.
    // Read only one byte for the header when the read pos is 0.
    NextOffset(state, newOffset) :- state is State(_, _, 0, _), newOffset = 1. 

    // Initialize the intermediate result "count" to the number in the first byte at the initial state.
    NextIntermediateResult("count", state, initialCount) :-
        Byte(inputData, asciiAsInt, 0),
        state is State(inputData, _, 0, _), 
        // TODO: This is a temporary workaround for ASCII conversion
        initialCount = asciiAsInt - 48.

    // Initialize the intermediate result "sum" to 0 at the initial state.
    NextIntermediateResult("sum", state, initialSum) :- state is State(inputData, _, 0, _),
        initialSum = 0.

    // Decide how many bytes to read next after the header is read.
    // Here we should read N bytes where N is the number we read from the header.
    // But for simplicity, we just read one byte at a time.
    NextOffset(state, newOffset) :- state is State(inputData, READ, pos, offset), 
        pos > 0, newOffset = 1.
        
    // Update the intermediate result "sum" with a new number extracted and added.
    // ASCII 35 is '#' and should be skipped.
    NextIntermediateResult("sum", newState, newSum) :- 
        oldState is State(inputData, READ, pos, offset),
        newState is State(inputData, UPDATE, pos, offset),
        pos > 0,
        NextOffset(state, offset),
        IntermediateResult("sum", oldState, oldSum),
        Byte(inputData, asciiAsInt, pos),
        asciiAsInt > 35,
        newSum = oldSum + asciiAsInt - 48.

    // The next position is the current position plus the offset unless you want to skip some bytes.
    NextPos(state, newPos) :- state is State(inputData, READ, pos, offset), newPos = pos + offset.
    
}

model m of TinyDemoParser {
    // Format: |header|#|digits| |header|#|digits| ...
    // The byte in the header decides how many digits to read and it will return the sum.
    // The header and the digits are separated by '#' and each expression is separated by space.
    // Example: "3#1234 3#45" 
    // "51(3) 35(#) 49(1) 50(2) 51(3) 52(4) 32(SPACE) 51(3) 35(#) 52(4) 53(5)" in ASCII format
    inputData is InputData("sample", "3#1234 3#45", 11).

    Byte(inputData,51,0), 
    Byte(inputData,35,1), 
    Byte(inputData,49,2), 
    Byte(inputData,50,3), 
    Byte(inputData,51,4),
    Byte(inputData,52,5),
    Byte(inputData,32,6), 
    Byte(inputData,51,7), 
    Byte(inputData,35,8),
    Byte(inputData,52,9), 
    Byte(inputData,53,10).

    initState is State(inputData, INIT, 0, 0). 
    initSum is IntermediateResult("sum", initState, 0).
}

partial model pm of GenericDataParser
[solver_RecursionBound = 5]
{
    InputData("sample", x, 100).
    requires atleast 200 Byte.
}