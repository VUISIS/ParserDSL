domain SimpleTarParser
{
  Header ::= new (name: Integer, size: Integer).
  Offset ::= new (name: Integer, pos: Integer).
  Start  ::= new (name: Integer).
  Done  ::= new (name: Integer, seq: Integer).

  Done(nextName, 0) :- s is Start(currName), 
                          currHeader is Header(currName, size),
                          currOffset is Offset(currName, pos),
                          nextPos = pos + size + 512,
                          nextOffset is Offset(nextName, nextPos).
                          
  Done(nextName, nextSeq) :- s is Done(currName, seq), nextSeq = seq + 1,
                          currHeader is Header(currName, size),
                          currOffset is Offset(currName, pos),
                          nextPos = pos + size + 512,
                          nextOffset is Offset(nextName, nextPos).

  badHeader :- h is Header, h.size < 0.

  // Must have exactly one StartHeader
  tooManyDone :- h is Header, name = h.name,
                    count({d | d is Done(name, _)}) > 1. 
  
  // conforms no tooManyDone, no badHeader.
}

partial model pm0 of SimpleTarParser
[solver_RecursionBound = 5]
{
  h1 is Header(100, 512).
  h1Offset is Offset(100, 0).
  Start(100).
  
  h2 is Header(101, x).
  h2Offset is Offset(101, 1024).
}

// A parser domain with dependent data types and intermediate results
domain GenericDataParser {
    // Define constants for parsing status
    Status ::= {INIT, READ, UPDATE, TERMINATE, DONE}.

    // A byte represented as an integer in the range of 0-255 and its location in the input data.
    Byte ::= new (input: InputData, val: Natural, pos: Integer).
    // Input data are bytes represented as a list of Byte.
    InputData ::= new (name: String, data: String, length: Integer).

    // Parsing state that the includes the input data, status, current position, and offset.
    State ::= new (inputData: InputData, status: Status, curPos: Integer, offset: Integer).

    // Intermediate results that are derived during parsing and the derived result could have my types.
    IntermediateResult ::= new (name: String, context: State, derivedResult: String + Integer + { NULL }).

    // Decide the new offset, pos and intermediate result based on current state.
    NextOffset ::= new (context: State, offset: Integer).
    NextPos ::= new (context: State, pos: Integer).
    NextIntermediateResult ::= new (var: String, context: State, result: String + Integer + { NULL }).

    CanReadMore ::= new (context: State).
    CanReadMore(state) :- state is State(InputData(_, _, length), _, pos, offset), 
        pos + offset < length.

    // Add more conditions as needed by implementing rules to derive `ContinueCondition` terms
    ContinueCondition ::= new (context: State).

    // Rule to move to done state
    State(inputData, DONE, pos, offset) :-
        inputData is InputData(name, data, length),
        State(inputData, READ, pos, offset), 
        offset + pos >= length.

    isDone :- State(_, DONE, _, _).

    // Rule to initialize the parser with no intermediate results, but you can add them as needed.
    State(initData, INIT, 0, 0) :- initData is InputData(_,_,_). // Change this logic as needed

    // Rule to read the next block of data based on the NextPos and NextOffset.
    // The conditions have to be satisfied in order to proceed to the next state.
    State(inputData, READ, newPos, newOffset) :-
        state is State(inputData, READ, pos, offset),
        NextPos(state, newPos),
        NextOffset(state, newOffset),
        ContinueCondition(state),
        CanReadMore(state).
    
    // Rule to update intermediate results from current read and other intermediate results.
    // The new status is changed from READ to UPDATE while keeping other parameters the same.
    IntermediateResult(name, newState, newDerivedResult) :-
        state is State(inputData, READ, pos, offset), 
        IntermediateResult(name, state, derivedResult),
        NextIntermediateResult(name, newState, newDerivedResult),
        newState = State(inputData, UPDATE, pos, offset).
}

domain GenericTarParser extends GenericDataParser {
    // Define constants for tar file types
    // Use String instead of Enum for simplicity
    // FileType ::= {PLAIN, LINK, DIRECTORY, SYMLINK, CHARDEV, BLOCKDEV, FIFO, UNKNOWN}.

    // TARFILETYPEOFFSET = 156.

    // Rule to determine file type based on header
    NextIntermediateResult("directory", state, 0), 
    NextIntermediateResult("files", state, newFilesVal) :-
        state is State(inputData, READ, pos, offset),
        IntermediateResult("files", state, filesVal),
        newFilesVal = filesVal + 1,
        Byte(inputData, typeByte, pos + 156),
        typeByte = 77. // ASCII value for 'M'

    NextIntermediateResult("directory", state, 1) :-
        state is State(inputData, READ, pos, offset),
        Byte(inputData, typeByte, pos + 156),
        typeByte = 86. // ASCII value for 'V'

    NextIntermediateResult("directory", state, 0), 
    NextIntermediateResult("skipEntry", state, 1) :-
        state is State(inputData, READ, pos, offset),
        Byte(inputData, typeByte, pos + 156),
        typeByte = 88. // ASCII value for 'X'

    // Default case for unknown file types
    NextIntermediateResult("fileType", state, "UNKNOWN") :-
        state is State(inputData, READ, pos, offset),
        Byte(inputData, typeByte, pos + 156),
        typeByte != 77,
        typeByte != 86,
        typeByte != 88.
    
    NextIntermediateResult("size", state, 1) :-
        state is State(inputData, READ, pos, offset),
        // TODO: Start at pos + 156, read the next 12 bytes and combine them to form a size.
        Byte(inputData, sizeByte, pos + 156),
        typeByte = 86. 

    NextIntermediateResult("nskip", state, 0) :- 
        state is State(inputData, READ, pos, offset),
        IntermediateResult("size", state, sizeVal),
        // TODO: Implement a function to handle `size` to `nskip` conversion.
        nskipVal = sizeVal.

    // block = fmap_need_off_once_len(*ctx->fmap, pos, BLOCKSIZE, &nread); 
    // TODO: nread is the actually available data in the block and could be less than 512.
    NextIntermediateResult("nread", state, 0) :- 
        state is State(inputData, READ, pos, offset).

    // Rule to handle checksum validation
    ContinueCondition(state) :- 
        state is State(inputData, READ, pos, offset),
        // TODO: Start at pos + 148, read the next 8 bytes and combine them to form a checksum.
        // TODO: Implement a checksum calculation function that takes the whole block as input.
        Byte(inputData, checksumByte, pos + 148),
        checksumByte = 0.

    // Rule to skip entries based on file type
    ContinueCondition(state) :- 
        state is State(inputData, READ, pos, offset),
        IntermediateResult("fileType", state, fileType),
        fileType != "UNKNOWN".

    // Rule to update position and offset for next block
    // pos will be affected by `nskip` under some conditions. pos += nskip.
    NextPos(state, newPos) :- state is State(inputData, READ, pos, offset), newPos = pos + offset.
    NextOffset(state, newOffset) :- state is State(inputData, READ, pos, offset), newOffset = 512.

    // Rule to handle file extraction logic
    State(inputData, UPDATE, pos, offset) :-
        state is State(inputData, READ, pos, offset),
        IntermediateResult("fileType", state, fileType),
        fileType = "PLAIN",
        // Logic to extract file (simplified)
        IntermediateResult("extracted", state, "yes").

    // Rule to finalize parsing
    State(inputData, DONE, pos, offset) :-
        state is State(inputData, UPDATE, pos, offset),
        IntermediateResult("extracted", state, "yes").
}

domain TinyDemoParser extends GenericDataParser {
    // Rule to initialize parsing and read the initial header or meta info.
    State(inputData, READ, pos, offset) :- State(inputData, INIT, 0, 0),
        pos = 0, offset = 1. 

    // Read the header and update the intermediate result with the count of numbers to read next.
    // Read only one byte for the header when the read pos is 0.
    NextOffset(state, newOffset) :- state is State(_, _, 0, _), newOffset = 1. 

    // Initialize the intermediate result "count" to the number in the first byte at the initial state.
    NextIntermediateResult("count", state, initialCount) :-
        Byte(inputData, asciiAsInt, 0),
        state is State(inputData, _, 0, _), 
        // TODO: This is a temporary workaround for ASCII conversion
        initialCount = asciiAsInt - 48.

    // If the first digit in the header is zero, the program should be terminated immediately
    ContinueCondition(state) :- state is State(inputData, _, pos, offset), 
        offset = 1,
        IntermediateResult("count", state, val),
        val = 0.

    // Initialize the intermediate result "sum" to 0 at the initial state.
    NextIntermediateResult("sum", state, initialSum) :- state is State(inputData, _, 0, _),
        initialSum = 0.

    // Decide how many bytes to read next after the header is read.
    // Here we should read N bytes where N is the number we read from the header.
    // But for simplicity, we just read one byte at a time.
    NextOffset(state, newOffset) :- state is State(inputData, READ, pos, offset), 
        pos > 0, newOffset = 1.
        
    // Update the intermediate result "sum" with a new number extracted and added.
    // ASCII 35 is '#' and should be skipped.
    NextIntermediateResult("sum", newState, newSum) :- 
        oldState is State(inputData, READ, pos, offset),
        newState is State(inputData, UPDATE, pos, offset),
        pos > 0,
        NextOffset(state, offset),
        IntermediateResult("sum", oldState, oldSum),
        Byte(inputData, asciiAsInt, pos),
        asciiAsInt > 35,
        newSum = oldSum + asciiAsInt - 48.

    // The next position is the current position plus the offset unless you want to skip some bytes.
    NextPos(state, newPos) :- state is State(inputData, READ, pos, offset), newPos = pos + offset.
    
}

model m of TinyDemoParser {
    // Format: |header|#|digits| |header|#|digits| ...
    // The byte in the header decides how many digits to read and it will return the sum.
    // The header and the digits are separated by '#' and each expression is separated by space.
    // Example: "3#1234 3#45" 
    // "51(3) 35(#) 49(1) 50(2) 51(3) 52(4) 32(SPACE) 51(3) 35(#) 52(4) 53(5)" in ASCII format
    inputData is InputData("sample", "3#1234 3#45", 11).

    Byte(inputData,51,0), 
    Byte(inputData,35,1), 
    Byte(inputData,49,2), 
    Byte(inputData,50,3), 
    Byte(inputData,51,4),
    Byte(inputData,52,5),
    Byte(inputData,32,6), 
    Byte(inputData,51,7), 
    Byte(inputData,35,8),
    Byte(inputData,52,9), 
    Byte(inputData,53,10).

    initState is State(inputData, INIT, 0, 0). 
    initSum is IntermediateResult("sum", initState, 0).
}

partial model pm of GenericDataParser
[solver_RecursionBound = 5]
{
    InputData("sample", x, 100).
    requires atleast 200 Byte.
}