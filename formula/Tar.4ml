domain TarParser extends GenericDataParser at "ParserDSL.4ml" {
    // The initial value of in_block is 0.
    NextIntermediateResult("in_block", state, 0) :- 
        state is State(inputData, INIT, 0, 0).

    // Set `in_block` to 1 at the end of reading the header block if not interrupted.
    NextIntermediateResult("in_block", state, 1) :- 
        state is State(inputData, _, _, _),
        IntermediateResult("in_block", state, 0),
        IntermediateResult("size", state, sizeVal),
        sizeVal = 0.

    // Reset `in_block` to 0 when the size is 0 indicating the end of file is reached and the next block is header again.
    NextIntermediateResult("in_block", state, 0) :- 
        state is State(inputData, _, _, _),
        IntermediateResult("in_block", state, 1),
        IntermediateResult("size", state, sizeVal),
        sizeVal = 0.

    // Define constants for tar file types
    // FileType ::= {PLAIN, LINK, DIRECTORY, SYMLINK, CHARDEV, BLOCKDEV, FIFO, UNKNOWN}.
    // TARFILETYPEOFFSET = 156.
    // Rule to determine file type based on header
    NextIntermediateResult("directory", state, 0), 
    NextIntermediateResult("files", state, newFilesVal) :-
        state is State(inputData, READ, pos, offset),
        IntermediateResult("files", state, filesVal),
        newFilesVal = filesVal + 1,
        IntermediateResult("in_block", state, inBlockVal),
        inBlockVal = 0,
        Byte(inputData, typeByte, pos + 156),
        typeByte = 77. // ASCII value for 'M'

    NextIntermediateResult("directory", state, 1) :-
        state is State(inputData, READ, pos, offset),
        IntermediateResult("in_block", state, inBlockVal),
        inBlockVal = 0,
        Byte(inputData, typeByte, pos + 156),
        typeByte = 86. // ASCII value for 'V'

    NextIntermediateResult("directory", state, 0), 
    NextIntermediateResult("skipEntry", state, 1) :-
        state is State(inputData, READ, pos, offset),
        IntermediateResult("in_block", state, inBlockVal),
        inBlockVal = 0,
        Byte(inputData, typeByte, pos + 156),
        typeByte = 88. // ASCII value for 'X'

    // Default case for unknown file types
    NextIntermediateResult("fileType", state, "UNKNOWN") :-
        state is State(inputData, READ, pos, offset),
        IntermediateResult("in_block", state, inBlockVal),
        inBlockVal = 0,
        Byte(inputData, typeByte, pos + 156),
        typeByte != 77,
        typeByte != 86,
        typeByte != 88.
    
    NextIntermediateResult("size", state, size) :-
        state is State(inputData, READ, pos, offset),
        // TODO: Start at pos + 156, read the next 12 bytes and combine them to form a size.
        Byte(inputData, sizeByte, pos + 156),
        // TODO: temporarily set it to a negative value or positive value for testing.
        size = 100.

    // Increment skipEntry if the size is less than 0.
    NextIntermediateResult("skipEntry", state, newSkipEntryVal) :-
        state is State(inputData, READ, pos, offset),
        IntermediateResult("in_block", state, inBlockVal),
        inBlockVal = 0,
        IntermediateResult("size", state, sizeVal),
        sizeVal < 0,
        IntermediateResult("skipEntry", state, skipEntryVal),
        newSkipEntryVal = skipEntryVal + 1,
        Byte(inputData, typeByte, pos + 156),
        typeByte = 88. // ASCII value for 'X'

    NextIntermediateResult("nskip", state, 0) :- 
        state is State(inputData, READ, pos, offset),
        IntermediateResult("size", state, sizeVal),
        // TODO: Implement a function to handle `size` to `nskip` conversion.
        nskipVal = sizeVal.

    // TODO: Model the following code: block = fmap_need_off_once_len(*ctx->fmap, pos, BLOCKSIZE, &nread); 
    // TODO: nread is the length of remaining data in a block and could be less than 512.
    NextIntermediateResult("nread", state, nreadVal) :- 
        inputData is InputData(_, _, length),
        state is State(inputData, READ, pos, offset),
        pos + offset < length,
        nreadVal = 512.

    NextIntermediateResult("nread", state, nreadVal) :- 
        inputData is InputData(_, _, length),
        state is State(inputData, READ, pos, offset),
        pos + offset >= length,
        nreadVal = (pos + offset) % 512.

    overread :- 
        IntermediateResult("nread", state, nreadVal),
        nreadVal < 512.

    // Rule to handle checksum validation, won't continue if the checksum is not valid.
    ContinueCondition(state) :- 
        state is State(inputData, _, pos, offset),
        // TODO: Start at pos + 148, read the next 8 bytes and combine them to form a checksum.
        // TODO: Implement a checksum calculation function that takes the whole block as input.
        Byte(inputData, checksumByte, pos + 148),
        // TODO: Loosen the requirement to simplify the logic or temporarily assume the checksum is valid.
        checksumByte > 0.

    // Rule to skip entries based on file type
    ContinueCondition(state) :- 
        state is State(inputData, _, pos, offset),
        IntermediateResult("fileType", state, fileType),
        fileType != "UNKNOWN".

    // Rule to update position and offset for next block
    // pos will be affected by `nskip` under some conditions. pos += nskip.
    NextPos(state, newPos) :- state is State(inputData, READ, pos, offset), 
        IntermediateResult("nskip", state, nskipVal),
        newPos = pos + offset + nskipVal.

    // It could be less than 512 depending on the value of nread.
    NextOffset(state, newOffset) :- state is State(inputData, READ, pos, offset), 
        IntermediateResult("nread", state, nreadVal), 
        // TODO: Can nreadVal be negative?
        newOffset = toNatural(nreadVal).

    // Rule to handle file extraction logic
    State(inputData, UPDATE, pos, offset) :-
        state is State(inputData, READ, pos, offset),
        IntermediateResult("fileType", state, fileType),
        fileType = "PLAIN",
        // Logic to extract file (simplified)
        IntermediateResult("extracted", state, "yes").

    // Rule to finalize parsing
    State(inputData, DONE, pos, offset) :-
        state is State(inputData, UPDATE, pos, offset),
        IntermediateResult("extracted", state, "yes").
}


model m of TarParser {
    initData is InputData("tarfile", "data", 1024).
}

// Commands for symbolic execution of a partial TarParser model.
// solve pm 1 isDone
// solve pm 1 overread
partial model pm of TarParser
[solver_RecursionBound = 5]
{
    inputData is InputData("sample", x, 10000).
    initState is State(inputData, INIT, 0, 0).
    requires atleast 10000 Byte.
}